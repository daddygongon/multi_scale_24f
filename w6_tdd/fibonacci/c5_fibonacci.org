#+qiita_public: 1bb27b8920c201d5c520
#+OPTIONS: ^:{}
#+STARTUP: indent nolineimages
#+TITLE: チャート式ruby-V(Recursive Fibonacci)
#+SUBTITLE: recursion(再帰)をtestで
#+AUTHOR: 西谷滋人
#+EMAIL:     (concat "nishitani@kwansei.ac.jp")
#+LANGUAGE:  jp
#+TAG: Ruby, TDD, Fibonacci

#+SETUPFILE: ~/.emacs.d/org-mode/theme-readtheorg.setup

* お題:Fibonacci数列
[[https://qiita.com/daddygongon/items/6f38d9a04e127a7952a7][チャート式Ruby]]の5回目，recursion(再帰)です．
#+begin_example
fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1)+fib(n-2) for n>=2
0 1 1 2 3 5 8 13 21 ...
#+end_example

| index | n      | 0 | 1 | 2 | 3 |
| val   | fin(n) | 0 | 1 | 1 | 2 |


をrecursion(再帰)で求めなさい．

* 解説
以下はTDDのバイブルのKent Beck本[^TDDbyKentBeck]に載っていたののアレンジです．
chart式の解法，解説，発展のサイクルがめちゃくちゃ短くなって，
TDDのred, green, refactoringに対応している感触を掴んでください．

[[https://qiita.com/daddygongon/items/f6cea87314ee26e130ea][前回]]作ったassert_equal.rbをcodes(作業directory)にcopyしておいてください．

* fib(0) = 0
Fibonacci数列の初項は0です．

- red ::  まずは表示させてみます．
          #+begin_src ruby
p fib(0)
#+end_src
          ないよね．
- green :: そこで，defします．
          #+begin_src ruby
def fib(n)
  if n==0
    return 0
  end
end
#+end_src
- refactoring :: assert_equal.rbのassertion(確認)を試しておきます．
          #+begin_src ruby
require './assert_equal'
puts assert_equal(0, fib(0))
#+end_src

* fib(1) = 1
次はfib(1)=1
- red :: まずはassertion
#+begin_src ruby 
puts assert_equal(1, fib(1))
#+end_src
もちろん失敗するが．．．
- green :: コピペ．
#+begin_src ruby
def fib(n)
  if n==0
    return 0
  end
  if n==1
    return 1
  end
end
#+end_src
これで通る．
- refactoring :: テスト側の重複が気になってきたので，配列にしよう．
#+begin_src ruby
[[0,0],[1,1]].each do |pair|
  puts assert_equal(pair[0], fib(pair[1]))
end
#+end_src
テストはもちろんgreen.

* refactoring
ここらへんまで来るとcodeがごちゃついてきた感じしません？
しない？　それは頭のいい人．私には無理．
えっと，rubocopという汚いcodeの取り締まり警官は10行以上のmethodがあると，
烈火のごとく怒ります．

治しようがないと思わずに削減を考えます．
求めよさらば与えられん．そんなに無理しなくても，
#+begin_src ruby
def fib(n)
  return 0 if n==0
  return 1 if n==1
end
#+end_src
と2行に削減できます．この記法も英語的でしょ．
それがrubyのいいところ．
これだと何をしているのか一目瞭然でしょ．
動いた部分を隠すというのがありますが，こっちの方がスマートです．
だからrefactoring(因数分解をもう一度)って名付けられています．

さらによく見ると
#+begin_src ruby
def fib(n)
  return n if n<=1
end
#+end_src
と一行になることにも気がつくはず．

* fib(2) = 1
** red
まずはテスト
#+begin_src ruby
[[0,0],[1,1],[2,1]].each do |pair|
#+end_src
なんですが，これはred.
#+begin_example
> ruby fibonacci_2.rb
expected:0
result :0
succeeded in assert_equal 0 should be expected.

expected:1
result :1
succeeded in assert_equal 1 should be expected.

expected:2
result :1
failed in assert_equal 1 should be expected.
#+end_example
** green 
returnを増やして，
#+begin_src ruby
def fib(n)
  return n if n<=1
  return 1
end
#+end_src
これで動くはず... おやおや．

実は，assert_equalは(expected, actual)とうけとっています．
#+begin_example
result = fib(2)
expected = 1
#+end_example
だから，テストは配列変数pairの示数indexが逆で，
#+begin_src ruby
require './assert_equal'
[[0,0],[1,1],[2,1]].each do |pair|
  puts assert_equal(pair[1], fib(pair[0]))
end
#+end_src
が正解．そうするとgreen.
** refactoring  
もう少し配列の受け取りを明示的にすると，
: index, expected = pair
と修正できて
#+begin_src ruby
require './assert_equal'
[[0,0],[1,1],[2,1]].each do |index, expected|
  puts assert_equal(expected, fib(index))
end
#+end_src
の方がいいかも，圧倒的にいい〜〜．

* fib(2) = 1 = fib(0) + fib(1)
** red & green
人間は賢いから上のように書いても納得するけど，computerはだめ．
sourceは
#+begin_src ruby
def fib(n)
  return n if n<=1
  return 1
end
#+end_src
でまずはgreenにしています．

** refactoring
そのあとでcodeを修正します．return 1の意味を考えると
: return 0+1
ですよね．さらには
: return fib(0) + fib(1)
というのも気がつくはず．
そうするとcodeは
#+begin_src ruby
def fib(n)
  return n if n<=1
  return fib(0) + fib(1)
end
#+end_src
です．これで通るのが不思議かもしれませんが，とおりますし，意味も
okです．

* fib(3) = fib(1) + fib(2) = 1 + 1 = 2
** red & green & refactoring = magic
次は3項目. 期待値は2ですね．
: [[0,0],[1,1],[2,1],[3,2]].each do |index, expected|
としましょう．テストはもちろんredです．
最後のreturnを定義通り
: fib(n) = fib(n-1) + fib(n-2)
と修正しましょう．

そうするとあら不思議．通ります．
そのさき1,1,2,3,5,8,13,21ももちろん．

最終形は，
#+name: sample
#+begin_src ruby
def fib(n)
  return n if n<=1
  return fib(n-1) + fib(n-2)
end

require './assert_equal'
[[0,0],[1,1],[2,1],[3,2],[4,3],
[5,5],[6,8],[7,13],[8,21]].each do |index, expected|
  puts assert_equal(expected, fib(index))
end
#+end_src
です．

* まとめ
うーーーん．こんなに綺麗にFibonacciを説明できるなんて．TDD万歳!![^DHH]


* 参照文献
[^TDDbyKentBeck]: テスト駆動開発, Kent Beck (著), 和田 卓人 (翻訳), オーム社; 新訳版 (2017/10/14).

[^DHH]: [[https://dhh.dk/2014/tdd-is-dead-long-live-testing.html][「TDD死すとも，testingは死せず」"TDD is dead. Long live testing." by David Heinemeier Hansson]]ってのもありますが．．．
